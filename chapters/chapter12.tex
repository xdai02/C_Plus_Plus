\chapter{封装}

\section{友元}

\subsection{友元函数}

封装使得类的数据对外隐藏，但是有些函数不是类的一部分，却又需要频繁访问类的数据成员，这时可以将这些函数定义为该类的友元函数。一个函数可以是多个类的友元函数，只需要在各个类中分别声明。除了友元函数，还有友元类。\\

友元（friend）的作用是提高程序的运行效率，减少了类型检查和安全性检查等需要的时间开销，但它破坏了类的封装性和隐藏性，使得非成员函数可以访问类的私有成员。\\

友元函数是可以直接访问类的私有成员的非成员函数。它是定义在类外的普通函数，它不属于任何类，但需要在类的定义中加以声明。

\vspace{-0.5cm}

\begin{lstlisting}[language=C++]
friend ret_type func_name([param_list]);
\end{lstlisting}

\vspace{0.5cm}

\mybox{友元函数}

\begin{lstlisting}[language=C++]
#include <iostream>
#include <cmath>

using namespace std;

class Coordinate {
public:
    Coordinate(double x, double y) : x(x), y(y) {};

    friend double distance(Coordinate &c1, Coordinate &c2);

private:
    double x;
    double y;
};

double distance(Coordinate &c1, Coordinate &c2) {
    double deltaX = c1.x - c2.x;
    double deltaY = c1.y - c2.y;
    return sqrt(deltaX * deltaX + deltaY * deltaY);
}

int main() {
    Coordinate c1(3, 5);
    Coordinate c2(4, 6);
    cout << distance(c1, c2) << endl;
    return 0;
}
\end{lstlisting}

\begin{tcolorbox}
	\mybox{运行结果}
	\begin{verbatim}
1.41421
	\end{verbatim}
\end{tcolorbox}

\newpage

\section{运算符重载}

\subsection{运算符重载}

C++中预定义的运算符的操作对象只能是基本数据类型，但实际上对于许多用户自定义类型（例如类），也需要类似的运算操作。这时就必须在C++中重新定义这些运算符，赋予已有运算符新的功能，使它能够用于特定类型执行特定的操作。运算符重载的实质是函数重载，它提供了可扩展性。\\

运算符重载是通过创建运算符函数实现的，运算符函数定义了重载的运算符将要进行的操作。运算符函数的定义与其它函数的定义类似，惟一的区别是运算符函数的函数名是由关键字operator和要重载的运算符符号构成。

\vspace{-0.5cm}

\begin{lstlisting}[language=C++]
ret_type operator op([param_list]) {
    // code
}
\end{lstlisting}

运算符重载需要遵循以下规则：

\begin{enumerate}
	\item 除了【.】、【->】、【sizeof】、【?:】和【\#】，其它运算符都可以重载。

	\item 重载后的运算符不能改变优先级和结合性，也不能概念运算符的操作数个数及语法结构。

	\item 运算符重载是针对新类型数据对实际需要的改造，重载后的运算符应当与原有功能相类似。
\end{enumerate}

\vspace{0.5cm}

\subsection{二元运算符重载}

二元运算符需要两个操作数，例如【+】、【-】、【*】、【/】等。\\

\mybox{二元运算符重载}

\begin{lstlisting}[language=C++]
#include <iostream>
#include <string>

using namespace std;

class Complex {
public:
    Complex(int real, int imaginary);
    string getNumber();
    Complex operator+(const Complex& c);

private:
    int real;
    int imaginary;
};

Complex::Complex(int real = 0, int imaginary = 0)
    : real(real), imaginary(imaginary) {}

string Complex::getNumber() {
    return to_string(real) + "+" + to_string(imaginary) + "i";
}

Complex Complex::operator+(const Complex& c) {
    Complex complex;
    complex.real = this->real + c.real;
    complex.imaginary = this->imaginary + c.imaginary;
    return complex;
}

int main() {
    Complex c1(1, 2);
    Complex c2(8, 1);
    Complex result = c1 + c2;
    cout << result.getNumber() << endl;
    return 0;
}
\end{lstlisting}

\begin{tcolorbox}
	\mybox{运行结果}
	\begin{verbatim}
9+3i
	\end{verbatim}
\end{tcolorbox}

\vspace{0.5cm}

\subsection{输入输出运算符重载}

C++使用流提取运算符【>>】和流插入运算符【<<】进行输入输出，通过运算符重载可以对自定义对象进行输入输出操作。通过把输入输出运算符重载函数声明为类的友元，可以直接调用函数而无需创建对象。\\

\mybox{输入输出运算符重载}

\begin{lstlisting}[language=C++]
#include <iostream>
#include <string>
using namespace std;

class User {
public:
    User(int id, string name);
    friend ostream& operator<<(
        ostream& out,
        const User& user);
    friend istream& operator>>(istream& in, User& user);

private:
    int id;
    string name;
};

User::User(int id = 0, string name = "")
    : id(id), name(name) {}

ostream& operator<<(ostream& out, const User& user) {
    out << "ID: " << to_string(user.id) << ", "
        << "name: " << user.name;
    return out;
}

int main() {
    User user;
    cin >> user;
    cout << user;
    return 0;
}
\end{lstlisting}

\begin{tcolorbox}
	\mybox{运行结果}
	\begin{verbatim}
Enter user ID: 1
Enter user name: Terry
ID: 1, name: Terry
	\end{verbatim}
\end{tcolorbox}

\newpage